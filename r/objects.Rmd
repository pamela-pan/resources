---
title: "Objects"
author: "Yun Dai"
date: "01/2019"
output: 
  html_document:
    theme: readable
    highlight: textmate
    toc: true
    toc_float: true
    css: contents.css
---

******
The data structures R operates on are called objects. Common types of objects include vectors, factors, arrays, matrices, lists, data frames, and functions. 

## Vectors
Vectors contain ordered numbers, or sequences, and it can only contain objects of the same class.

Vector is the most important object in R as much of R is “vectorized”. This means that a function works on a whole vector, and there is no need to loop over all values of the vector. 

```{r}
2013 : 2018 ## creates a numeric vector 
```

```{r}
c(TRUE,FALSE,TRUE,TRUE) ## creates a logical vector 
```

Vectors of different lengths can appear in the same expression; but the shorter one will be recycled until it matches the longer one.
```{r}
c(1:10) * c(2,3)
```

We will receive a warning if the length of the longer object is not a multiple of the length of the shorter object.
```{r}
c(1:10) * c(2,3,3)
```

There are several ways to generate a vector of sequences using the `:` operator and functions `c()`, `seq()`, `rep()` and `paste()`.

******
### :  operator
`:` generates regular sequences of numbers from the specified starting value to the end value.
```{r}
1:10
```

```{r}
10:1
```

Note the priority of the colon operator in an expression. Multiplication is applied to each element of a vector generated by 1:10.
```{r}
1:10*3 
```

******
### c()
`c()` is the concatenate function that combines values into a vector or a list.

```{r}
c(1:10, 25, 35)
```

******
### seq()
`seq()` generates regular sequences.

```{r}
seq(from = 3,to = 30)
```

```{r}
seq.int(3, 30) ## same as above, faster
```

```{r}
seq(from = 3, to = 30, by = 3) ## generates a sequence from 3 to 30 with an interval of 3
```

```{r}
seq.int(3, 30, 3) ## same as above, faster
```

```{r}
seq(from = 3, to = 30, length.out = 10) ## generates a sequence from 3 to 30 and sets the vector length to be 10
```

***
`seq_len()` generates a sequence that starts at 1 and finishes at the specified value with an interval of 1. 
```{r}
seq_len(10) ## generates a sequence of length 10 from 1
```

In the example below, `seq_len()` creates indexes for each element in the vector `input`; the for loop then runs over each element in the vector. 
```{r eval=FALSE}
for (i in seq_len(length(input))) {}
```


***
`seq_along()` generates a sequence from 1 to the length of the vector.
```{r}
seq_along(c("shanghai", "new york", "abu dhabi")) 
```

******
### rep()
`rep()` generates a vector by replicating the elements.

```{r}
rep(1:5, times = 3) 
```

```{r}
rep.int(1:5, 3) ## same as above, faster
```

```{r}
rep(1:5, each = 3) 
```

```{r}
rep(1:5, c(2,3,2,3,2)) 
```

```{r}
rep(1:5, length.out = 10) 
```

```{r}
rep_len(1:5, 10) ## same as above, faster  
```

******
### paste()
`paste()` concatenates character vectors.

```{r}
paste(c("nyu"), c("shanghai", "new york", "abu dhabi")) 
```

******
### length()
Length is an attribute of the vector that tells us how many elements a vector contains. 

`length()` returns the length of a vector.
```{r}
length(rep(1:5, each = 3)) 
```

***
`length()` is also useful in loops.

For instance, in the for loop below, we are appending the .csv files in the list of file names (`logs`) from the first one to the last one (`1:length(logs)`). 
```{r eval=FALSE}
logs <- list.files(pattern = "*.csv")

df <- data.frame()

for (i in 1:length(logs)) {
  temp <- read_csv(logs[i])
  df <- bind_rows(df, temp)   
}
```

In another example, the while loop runs as long as the upper limit `upper` has not reached the end of the vector `user`.
```{r eval=FALSE}
lower <- 1
upper <- lower + 49
while (upper < length(user)){
  user_file <- get_timeline(user[lower:upper], n = 3200)
  write_as_csv(user_file, paste("protester", lower, ".csv", sep = ""))
  lower <- upper + 1
  upper <- lower + 49
}
```

******
## Factors
Factors are ordered or unordered vectors of categorical objects. Factors are integer vectors with character labels.

```{r}
f <- factor(c("chocolate", "vanilla", "strawberry"))  ## returns the factor elements as well as the levels
f
```

******
### levels
`levels()` returns the levels, or the "categories", of a factor.

```{r}
levels(f) 
```

`nlevels()` returns the number of levels of the factor.
```{r}
nlevels(f)
```

Specifying the levels argument to `factor()` allows us to manually set the levels of the factor.
```{r}
factor(c("chocolate", "vanilla", "strawberry"), levels = c("strawberry", "vanilla", "chocalate"))
```


***
### using factors
Factors are useful in running regressions that have categorical variables with orders.
```{r message=FALSE,warning=FALSE}
library(dplyr)
storms <- storms
class(storms$category)
levels(storms$category)
```

```{r}
summary(lm(wind ~ category, data = storms))
```

***
Factors are also useful in graphs to reorder levels of a variable.

```{r include=FALSE}
load("/Volumes/GoogleDrive/My Drive/websites/new web/data/r/sample/dtset")
```


```{r message=FALSE,warning=FALSE}
library(ggplot2)

ggplot(dtset, aes(x = reorder(Reason, Total), y = Total, fill = factor(Level, levels = c("High","Medium","Low")))) + 
  geom_bar(stat = "identity", alpha = 0.75) + 
  scale_fill_manual(values = c("#765285", "#709FB0", "#D1A827"), name="Level of\nFrequency") +
  coord_flip() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12, margin = margin(0,3,0,0)),
        axis.title.y = element_blank(),
        axis.title.x = element_text(size = 12, margin = margin(15,0,0,0)),
        axis.ticks.x = element_line(size = 0),
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 12),
        plot.margin = unit(c(0,0,1,0), "cm")) 
```

***
### converting factors
A factor can be converted to character using `as.character()`.
```{r}
f <- factor(c("chocolate", "vanilla", "strawberry"))  ## returns the factor elements as well as the levels
f2 <- as.character(f)
class(f2)
```

A factor can be converted to numeric using `as.numeric(as.character())`.
```{r}
category <- storms$category
category2 <- as.numeric(as.character(category))
class(category2)
```

Or through `as.numeric(levels())[]`.
```{r}
category3 <- as.numeric(levels(category))[category]
class(category3)
```


******
## Matrices and Arrays
Arrays are multidimensional vectors.

******
### matrices
A matrix is a vector with two dimensions, and a special type of the array that has two dimensions.

`matrix()` creates matrices. By default data are filled by columns unless specified otherwise. The dimension names `dimnames` must be defined by a list.

```{r}
matrix(1:12, ncol = 3, nrow = 4, byrow = TRUE, dimnames = list(c("r1","r2","r3","r4"), c("c1","c2","c3")))
```

`cbind()` and `rbind()` can also create matrices by combining columns or rows of matrices or vectors.
```{r}
m1 <- matrix(1:9, ncol = 3, nrow = 3) 
m2 <- matrix(10:12, ncol =1, nrow = 3)
m3 <- matrix(10:12, ncol = 3, nrow = 1) 
cbind(m1, m2) 
```

```{r}
rbind(m1, m3) 
```

***
#### matrix operations
R offers rich [matrix operators](http://www.philender.com/courses/multivariate/notes/matr.html). Basic operations that can be applied to modify matrices include matrix addition, scalar multiplication, transposition, matrix multiplication, and more.

For instance, matrix addition:
```{r}
A <- matrix(c(1:12), 3, 4) 
B <- matrix(c(13:24), 3, 4) 
A + B
```

Matrix multiplication:
```{r}
A * B
```

Transposition:
```{r}
t(A)
```


******
### arrays
`array()` creates an array, where the dimension attribute is defined by an integer vector.
```{r}
a <- array(1:12, dim = c(2,2,3)) 
a
```

```{r}
attributes(a) 
```

```{r}
dim(a) 
```


******
## Lists
Lists are vectors that store objects of different classes, while vectors, factors, arrays and matrices must have elements of the same class.

`list()` creates a list.
```{r}
list(c(1:3), TRUE, "black") 
```

Within the lists we can specify the object names.
```{r}
L1 <- list(vector = c(1:3), logical = TRUE, character = "black") 
L1
```

***
Lists can be nested.
```{r}
L2 <- list(A = c(1:10), B = matrix(1:6, ncol = 3, nrow = 2), C = list(c("a","b","c"), c(TRUE, FALSE), factor(c("one","two","three")))) 
L2
```

***
`unlist()` can be used to flatten a list to a vector.
```{r}
unlist(L2) 
```

******
## Data frames
Data frames are spreadsheet-like objects. Data frame components can be vectors, factors, matrices, lists, or other data frames.

Columns of the data frames can store data of different classes but they must be of the same length.

Data frames can be created by `data.frame()`.

```{r}
df<-data.frame(A = c(1:2), B = matrix(1:4, ncol = 2, nrow = 2), C = list(c("a","b"), c(TRUE, FALSE), factor(c("one","two"))))
df
```

Data frame attributes include row names `rownames()`, column names `colnames()`, dimension names `dimnames()`, number of rows `nrow()`, number of columns `ncol()`, dimensions `dim()` etc. 

```{r}
rownames(df) 
```

```{r}
colnames(df)
```

```{r}
dimnames(df) 
```

```{r}
nrow(df)
```

```{r}
ncol(df)
```

```{r}
dim(df)
```

## Classes
The five atomic object classes are numeric, integer, complex, factor, logical, and character. Objects of atomic classes can only contain elements of the same class. Vectors, factors, arrays, and matrices belong to the atomic class.

Objects of recursive classes, on the other hand, can contain objects of the same class as themselves. Lists can contain lists, for instance. Lists, data frames and functions are of the recursive class.

******
### `class()`
`class()` returns the class of an object. There are three numeric object classes: numeric, integer and complex.

```{r}
class(1:10*3) ## floating point numbers
```

```{r}
class(1:10) ## integers
```

```{r}
class(1L)  ## adding the suffix “L” can make the number an integer
```

```{r}
class(2+3i)  ## complex numbers
```

```{r}
class(c("chocalate", "vanilla", "strawberry"))
```

******
### evaluating object types
`is.()` evaluates if the object is of the object type specified.
```{r}
f <- factor(c("chocalate", "vanilla", "strawberry")) 
is.factor(f) 
```

Note that `is.numeric()` returns true for both integers and floating point numbers.

******
### converting object types
`as.` coerces the object to the specified class.
```{r}
as.character(f) ## coerces f from factor to character
```

******
## Attributes
We have discussed several attributes of objects: class, levels, length, dimensions, names etc.  `attributes()` returns the attributes of an object.